\documentclass[10pt,a4paper]{report}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{Sweave}
\SweaveOpts{prefix.string=plots/pl}
\author{Dorottya Cserpan}

\begin{document}

\section{kCSD for Ballstick Modell}


<<beolvasas,echo=FALSE>>=
#source('/media/BA0ED4600ED416EB/agy/kCSD/progik/ballsctick/ballstick.R')
#Sweave('/media/BA0ED4600ED416EB/agy/kCSD/progik/bs_futtat//bs_130509/bs_1D_130509line.Rnw')
hovament<-'/media/BA0ED4600ED416EB/agy/kCSD/progik/bs_futtat/branching'
setwd('/media/BA0ED4600ED416EB/agy/kCSD/progik/bs_futtat/branching')
library('R2Cuba')
library('corpcor')
library('fields')


####################################
#########   FUNCTIONS
########################################
#interpolacio (mosthol, ertek, hol legyen)
interpol<-function(xbe,y,xki){
inter<-splinefun(xbe,y,method="monoH.FC")
out<-inter(xki)
return(out)
}


#######################################
########### BRANCHING
#####################################
#First just get the coordinates of the beginning and the end of the branches
branch.nb<-4 #number of branches
branch.beg<-array(0,c(branch.nb,3))
branch.end<-array(0,c(branch.nb,3))

branch.beg[1,3]<--9.4
branch.end[1,3]<-+9.4
branch.beg[2,3]<-+9.4
branch.end[2,3]<-390.6
#branch.beg[3,3]<-+9.4
#branch.end[3,3]<-+341.3
#branch.beg[3,1]<-2.94
#branch.end[3,1]<-50
branch.beg[3,3]<-390.6
branch.end[3,3]<-440.5
branch.beg[4,3]<--9.4
branch.end[4,3]<--159.4
#how long is the cell?
branch.length<-sqrt(rowSums((branch.beg-branch.end)^2))
cell.length<-sum(branch.length)



#####################################x
#GETTING DATA AND PARAMETERS
#1D kCSD for cells
#reading in the middle points of the segments
seg.cord<-as.matrix(read.table('coordsmid_x_y_z'))
seg.cord<-matrix(seg.cord,ncol=3)
#seg.kord<-matrix(0,c(dim(seg.cord)))

seg.kord<-seg.cord


seg.start<-matrix(as.matrix(read.table('coordsstart_x_y_z')),ncol=3)

seg.end<-matrix(as.matrix(read.table('coordsend_x_y_z')),ncol=3)

seg.diam<-as.matrix(read.table('segdiam_x_y_z'))

seg.db<-length(seg.diam)


#time
time<-as.matrix(read.table('time'))

#cell to electrode distance
d<-as.matrix(read.table("elprop"))[1]

#length of the segments
seg.length<-as.matrix(read.table('seglength'))

#cell.length<-sum(seg.length)
#coordinates of electrode
elec.kord<-as.matrix(read.table('elcoord_x_y_z'))
elec.kord<-matrix(elec.kord,ncol=3)
elec.dist<-elec.kord[2,3]-elec.kord[1,3]
el.nb<-dim(elec.kord)[1] #number of electrodes
sigma<-as.matrix(read.table('elprop'))[2] #sigma
#membrane currents
memb.currents<-as.matrix(read.table('membcurr'))


##############################################
############## Source coordinates
################################################
M<-as.numeric(read.table('basenum.txt')) #number of sources (a feltételezett források szama a sejten)
#delta<-cell.length/(M) #shift of overlapping sources on average
#would be nice to seperate the basis functions according to the branches they belong to
#the basis functions should be distirbuted evenly along the branches, let's valculate how many basis functions belongs the the different branches
#########################################
################# Parent-children
#####################################x
#all the basis of one segment functions should go through the paren and its child #is this going to result a huge number of basis functions?

delta<-cell.length/(M) 
source.branch.db<-round(branch.length/cell.length*M)
source.cord<-numeric()
for(i in 1:branch.nb){
t<-array(seq(-0.05,1.05,length.out=source.branch.db[i]),c(1,source.branch.db[i]))
source.cord<-c(source.cord,array(branch.beg[i,],c(3,source.branch.db[i]))+(branch.end[i,]-branch.beg[i,])%*%t)
}
source.cord<-matrix(source.cord,ncol=3,byrow=TRUE)


# real number of the basis functions
M<-sum(source.branch.db)
#col1: which basis, col2: which branch
source.branch<-array(0,c(M,2))
source.branch[,1]<-c(1:M)
source.branch[,2]<-c(rep(1:branch.nb,as.matrix(source.branch.db)))

#where do we want to ge the values of currents

where.cord<-numeric()
for(i in 1:branch.nb){
t<-array(seq(0.0,1,length.out=source.branch.db[i]),c(1,source.branch.db[i]))
where.cord<-c(where.cord,array(branch.beg[i,],c(3,source.branch.db[i]))+(branch.end[i,]-branch.beg[i,])%*%t)
}
where.cord<-matrix(where.cord,ncol=3,byrow=TRUE)
#to which branch do the different points of calculation belong to?
where.db<-M
#where.cord<-source.cord
where.branch<-source.branch




#lfp
LFP<-as.matrix(read.table('myLFP'))

#LFP<-LFP.calc/1000000 #most mV-ban van
@


Parameters:

<<parameterek,echo=FALSE>>=

#Parameters



d<-as.matrix(read.table('elprop'))[1] #distance of electrode

#R<- 20 #width of Gaussian or length of step funtion
R<-as.numeric(read.table('basewidth.txt'))

#base<-'step' #type of base function ('step', 'Gaussian')
#base<-'gauss'
base<-paste(readLines('basetype.txt')) #getting it from a text file made by the .sh file
#printing the parameters to the pdf file 
cat(paste('Number of electrodes:',el.nb))
cat(paste('Number of base functions:',M))
cat(paste('Number of segments:',seg.db))
cat(paste('Type of base functions:',base))
cat(paste('Width of base functions:',R, 'um'))
cat(paste('sigma:',sigma))
cat(paste('Shift of overlapping of base functions:', delta, 'um'))
cat(paste('Cell to electrode distance:',d))

@

Units:
<<units,echo=FALSE>>=
cat('Potential 	  [mV]')
cat('Current      [nA]')
cat('Conductivity [S/m]') 
#cat('Capacitance 	[μF/cm2]')
cat('Dimension 	  [μm]')
#cat('Syn. weight 	[nS]')
@


<<bazisfgv,echo=FALSE>>=
#location of base function



const<-1/(4*pi*sigma) 

####################### kCSD

#i function,in r position, i source's coordinate: source.cord
#r_t ahol ki akarom számolni


#The calculations should just be done in the same branches...
#b.tilda.i(i,R,source.cord,where.cord[j,])
b.tilda.i<-function(i,R,source.cord,cord)
{
out<-numeric()
xl<-cord[1]
yl<-cord[2]
zl<-cord[3]

if (base=='gauss') {out<-exp(-((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)/(R^2))}
if (base=='step'){ 
thresh1<-((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)
if ( thresh1<= R^2)  out<-1 #itt eredetileg (R/2 volt)
else out<-0

} #step
if (base=='cos'){ 
distan1<-sqrt((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)
value<-pi/R*distan1
if (distan1<= R/2) out<-cos(value)
if(distan1 > R/2) out<-0}

if (base=='sinxpx'){
distan1<-sqrt((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)
value<-4*pi/R*distan1
if (distan1<= R/2 & distan1!=0) out<-sin(value)/value
if (distan1==0) out<-1
if(distan1 > R/2) out<-0}


return(out)
}


b.i<-function(i,R,source.cord,r){


#x,y,z szerint integrálunk
fun<-function(t){


xl<-a[1]+(b[1]-a[1])*t
yl<-a[2]+(b[2]-a[2])*t
zl<-a[3]+(b[3]-a[3])*t

if (base=='gauss'){ ff<- (exp(-((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)/(R^2)))/sqrt((r[1]-xl)^2+(r[2]-yl)^2+(r[3]-zl)^2)*sqrt((b[1]-a[1])^2+(b[2]-a[2])^2+(b[3]-a[3])^2)}

if (base=='step'){
thresh1<-((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)
if ( thresh1<= R^2) {ff<- 1/sqrt((r[1]-xl)^2+(r[2]-yl)^2+(r[3]-zl)^2)*sqrt((b[1]-a[1])^2+(b[2]-a[2])^2+(b[3]-a[3])^2) }
else ff<-0
}

if (base=='cos'){ 
distan1<-sqrt((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)
value<-pi/R*distan1
if (distan1<= R/2) ff<-cos(value)/sqrt((r[1]-xl)^2+(r[2]-yl)^2+(r[3]-zl)^2)*sqrt((b[1]-a[1])^2+(b[2]-a[2])^2+(b[3]-a[3])^2)
if(distan1 > R/2) ff<-0}

if (base=='sinxpx'){
distan1<-sqrt((source.cord[i,1]-xl)^2+(source.cord[i,2]-yl)^2+(source.cord[i,3]-zl)^2)
value<-4*pi/R*distan1
if (distan1<= R/2 & distan1!=0) ff<-sin(value)/value/sqrt((r[1]-xl)^2+(r[2]-yl)^2+(r[3]-zl)^2)*sqrt((b[1]-a[1])^2+(b[2]-a[2])^2+(b[3]-a[3])^2)
if (distan1==0) ff<-1
if(distan1 > R/2) ff<-0}




return(ff)
}


#integralt<-integrate(Vectorize(fun), -Inf,Inf,rel.tol=0.001)
#it is possible,that the
integralt<-integrate(Vectorize(fun), -0.4,1.4)
#integralt<-integrate(Vectorize(fun), (source.cord[i,3]-a[3]-3*R)/(b[3]-a[3]),(source.cord[i,3]-a[3]+3*R)/(b[3]-a[3]))
#integralt<-cuhre(1,1,fun,lower=as.vector((source.cord[i,3]-10*R)/(b[3]-a[3])),upper=as.vector( (source.cord[i,3]+10*R)/(b[3]-a[3])),flags=list(verbose=0))
#integralt<-cuhre(1,1,Vectorize(fun),lower=as.vector((-0.5)),upper=as.vector(1 ),flags=list(verbose=0))

#bi.value<-const*integralt$value
bi.value<-integralt$value

return(bi.value)
}


@

<<setuppara,echo=FALSE>>=

####ABRA az elrendezesrol
# ki kene rajzolni a neuronos szegmenseket, vastagsag stb
#merolegesen rarajzolni a bazisfuggvenyeket

db<-1:length(seg.diam)
setwd(hovament)
@

<<setup,fig=TRUE,echo=FALSE>>=


plot(elec.kord[,1],elec.kord[,3],xlim=c(-35,d+10),pch=15,xlab="x (um)",ylab="y (um)", main="Simulational setup",ylim=c(seg.start[1,3]-10,seg.end[seg.db,3]-10))
points(seg.kord[,1],seg.kord[,3],pch=20)
points(source.cord[,1],source.cord[,3],col='RED')
rect(-seg.diam[db]/2,seg.start[db,3],seg.diam[db]/2,seg.end[db,3])

if (base=='step'){
rect(-30,source.cord[1:M,3]-R/2,-20,source.cord[1:M,3]+R/2,col=rainbow(1,start=0.3,alpha=0.3))
}
if (base=='gauss'){
for(j in 1:M){
x<-matrix(-100:600,ncol=1)
gaus<-function(r.t) exp(-sum((source.cord[j,3]-r.t)^2)/(R^2))
y<-apply(x,1,gaus)
lines(-10*y-20,x)
}
}


if (base=='cos'){
for(j in 1:M){
x<-matrix((source.cord[j,3]-R/2):(source.cord[j,3]+R/2),ncol=1)
cosinus<-function(r.t) cos(pi/R*(source.cord[j,3]-r.t))
y<-apply(x,1,cosinus)
lines(-10*y-20,x)
}
}

if (base=='sinxpx'){
for(j in 1:M){
#x<-matrix(-100:600,ncol=1)
x<-matrix((source.cord[j,3]-R/2):(source.cord[j,3]+R/2),ncol=1)
sinxpx<-function(r.t) ifelse(((source.cord[j,3]-r.t)!=0),  sin(4*pi/R*(source.cord[j,3]-r.t))/(4*pi/R*(source.cord[j,3]-r.t)),1)

y<-apply(x,1,sinxpx)
lines(-10*y-20,x)
}
}

legend("topleft",c("centre of bf","middle of seg","electrodes"),col=c("RED","BLACK","BLACK"),pch=c(1,1,15),bg="WHITE" )

png("elrendezes.png",width=400, height=400)
plot(elec.kord[,1],elec.kord[,3],xlim=c(-50,d+10),pch=15,xlab="x (um)",ylab="y (um)", main="Simulational setup")
points(seg.kord[,1],seg.kord[,3],pch=20)
points(source.cord[,1],source.cord[,3],col='RED')
rect(-seg.diam[db]/2,seg.start[db,3],seg.diam[db]/2,seg.end[db,3])

#rect(-40,source.cord[1:M,3]-R/2,-30,source.cord[1:M,3]+R/2,col=rainbow(1,start=0.3,alpha=0.3))


for(j in 1:M){
x<-matrix(-100:600,ncol=1)
gaus<-function(r.t) exp(-sum((source.cord[j,3]-r.t)^2)/(R^2))
y<-apply(x,1,gaus)
lines(-10*y-13,x)
}
legend("topleft",c("centre of bf","middle of seg","electrodes"),col=c("RED","BLACK","BLACK"),pch=c(1,20,15),bg="WHITE" )
dev.off()

@

More detailed setup:
<<setup2,fig=TRUE,echo=FALSE>>=
coloursline<-rainbow(7)
plot(elec.kord[,1],elec.kord[,3],xlim=c(-83,d+10),pch=15,xlab="x (um)",ylab="y (um)", main="Simulational setup",ylim=c(-50,50))
rect(-seg.diam[db]/2,seg.start[db,3],seg.diam[db]/2,seg.end[db,3],col="seashell1")
points(seg.kord[,1],seg.kord[,3],pch=20,lwd=3)
points(source.cord[,1],source.cord[,3],col=coloursline,pch=20,lwd=2)


rect(-50+((1:M)%%7)*2,source.cord[1:M,3]-R/2,-35,source.cord[1:M,3]+R/2,border=coloursline[1:7],lwd=2)


for(j in 1:M){
x<-matrix(-100:600,ncol=1)
gaus<-function(r.t) exp(-sum((source.cord[j,3]-r.t)^2)/(R*2))
y<-apply(x,1,gaus)
lines(-10*y-20,x,col=coloursline[1+(j-1)%%7],lwd=2)
}




for(j in 1:M){
x<-matrix((source.cord[j,3]-R/2):(source.cord[j,3]+R/2),ncol=1)
cosinus<-function(r.t) cos(pi/R*(source.cord[j,3]-r.t))
y<-apply(x,1,cosinus)
lines(-10*y-55,x,col=coloursline[1+(j-1)%%7],lwd=2)
}



for(j in 1:M){
#x<-matrix(-100:600,ncol=1)
x<-matrix((source.cord[j,3]-R/2):(source.cord[j,3]+R/2),ncol=1)
sinxpx<-function(r.t) ifelse((((source.cord[j,3]-r.t))!=0),  sin(4*pi/R*(source.cord[j,3]-r.t))/(4*pi/R*(source.cord[j,3]-r.t)),1)
y<-apply(x,1,sinxpx)
lines(-10*y-70,x,col=coloursline[1+(j-1)%%7],lwd=2)
}



legend("topleft",c("centre of bf","middle of seg","electrodes"),col=c("RED","BLACK","BLACK"),pch=c(1,1,15),bg="WHITE" )

@



<<elefpes,fig=TRUE, echo=FALSE>>=
##################
#ábra az LFProl

#plotting LFP
par(mfrow=c(2,1))
matplot(time,t(LFP),t='l',xlab='time (ms)',ylab='LFP')
image.plot(time,elec.kord[,3],t(LFP),xlab='time (ms)',ylab='LFP',col=rainbow(40))


@


<<kernelszamolas,fig=TRUE,echo=FALSE>>=

library(foreach)
library(doMC)
#registerDoMC(cores=4)
registerDoMC(cores=16)

################# 
#Számoljuk ki a B illetve B.tilda mátrixot
#egy sor egy adott i-hez tartozó fgv, oszlopokban azonos helyekhez tartozó
#[i,j] : az i.függvény a j-dik helyen

source.nb<-M

#branch #melyik branchen vagyunk????


B.tilda<-array(0,c(source.nb,where.db))
B<-array(0,c(source.nb,el.nb))
for(i in 1:source.nb){
whichbranch<-source.branch[i,2]
a<-branch.beg[whichbranch,]
b<-branch.end[whichbranch,]

#cat(i)
Bj.result<-numeric(el.nb)
Bj.result<-foreach(j=1:el.nb,.combine=c) %dopar% {
b.i(i,R,source.cord,elec.kord[j,])
}
B[i,]<-Bj.result

B.t.j.result<-numeric(where.db)
B.t.j.result<-foreach(j=1:where.db,.combine=c) %dopar% {
#b.tilda.i(i,R, source.cord,source.cord[j,]) #ide a t-nek a megfelelő értékét kéne beírni a source coord helyén
b.tilda.i(i,R, source.cord,where.cord[j,]) #if (b[3]-a[3])!=0 !!

}
B.tilda[i,]<-B.t.j.result
#ha az i és j nem ugyanabban a branchben vannak, akkor ki kéne nullázni...

B.tilda[i,c(which(source.branch[i,2]!=source.branch[,2]))]<-0
} #i


K<-array(0,c(el.nb,el.nb))
K.tilda<-array(0,c(source.nb,el.nb))

K<-t(B)%*%B
K.tilda<-t(B)%*%B.tilda

C<-1/const*t(K.tilda)%*%solve(K)%*%LFP#*1000000#hogy nV-ban legyen az LFP ,
#C<-C/10^6 #a sigmaban cm^2-et használnak



sinxx<- function (x) {
out<-ifelse((x!=0), sin(4*pi/R*x)/(4*pi/R*x),1)
return(out)}

#C.curr.many<-C
#for (i in 1: where.db) C.curr.many[i,]<-C[i,]*(where.cord[where.db,3]-where.cord[1,3])/(where.db-1)
#A density fgv-t kiintegralva kapjuk meg az aramot!!
C.curr<-array(0,dim(memb.currents))
#piece.length<-(where.cord[where.db,3]-where.cord[1,3])/(where.db-1)
for(t in 1:length(time)){
inter<-splinefun(where.cord[,3],C[,t],method="monoH.FC")
for(db2 in 1:seg.db ) {output<-integrate(inter,seg.kord[db2,3]-seg.length[db2]/2,seg.kord[db2,3]+seg.length[db2]/2)
C.curr[db2,t]<-output$value
}

}
C.dens<-C
#Check whether the sum of current is 0



memb.current.colsum<-colSums(memb.currents)
C.curr.colsum<-colSums(C.curr)
plot(time,memb.current.colsum,t='l',main='Sum of Membrane Currents',ylim=range(memb.current.colsum,C.curr.colsum))
lines(time,C.curr.colsum,col='RED')
legend('topright',c('Original', 'Estimated'),lty=1,col=c('BLACK','RED'))

#measure based on the difference from the original membrane current (sum)
measure.curr<-sqrt(sum(memb.current.colsum-C.curr.colsum)^2)
#C<-t(K.tilda)%*%pseudoinverse(K)%*%LFP
#measure of peakness
min.indexes<-which(C.curr==min(C.curr),arr.ind=TRUE)
measure.peakness<--(min(C.curr)-mean(C.curr[-min.indexes[1],min.indexes[2]]))/sqrt(sum(C.curr[,min.indexes[2]]^2))



###########################################
############x coloured morphology
###########################################

par(mfrow=c(2,1),bg='BLACK')
image(t(memb.currents), col=rainbow(150))
image(t(C), col=rainbow(150))

where.cord[which()]

par(mfrow=c(1,2),bg='BLACK')

min.indexes<-which(C==min(C),arr.ind=TRUE)[2]
szinskala<-color.scale(c(C[,min.indexes]),col=rainbow(150))
plot(where.cord[,1],where.cord[,3],pch=16,col=szinskala,asp=1)

szinskala2<-color.scale(c(memb.currents[,min.indexes]),col=rainbow(150))
plot(seg.cord[,1],seg.cord[,3],pch=16,col=szinskala2,asp=1)

plot(seg.kord[,3],memb.currents.vonal[,min.indexes])
points(where.cord[,3],C[,min.indexes],col='RED')

@




<<membcurrentplot,fig=TRUE,echo=FALSE>>=
par(mfrow=c(2,1),mar=c(5.1, 4.1, 4.1, 12.1), xpd=TRUE)
th.l<-min(C.curr,memb.currents)
th.u<-max(C.curr,memb.currents)
limitsodcurr<-max(abs(max(C.curr,memb.currents)))
matplot(time,t(memb.currents),t='l',main='Membrane currents',xlab="time (ms)", ylab="Current (nA)",ylim=c(th.l,th.u))
matplot(time,t(C.curr),t='l',main='Estimated MC',xlab="time (ms)", ylab="Current (nA)",ylim=c(th.l,th.u))
legend('topright',db,db, col=db,lty=1:6,bg="WHITE",inset=c(-0.6,0),ncol=2)
@


<<peakes,fig=TRUE,echo=FALSE>>=
plot(seg.kord[,3],memb.currents[,min.indexes[2]],t='l',main='Currents at the peak of the %spike',ylim=c(-2,1.5))
lines(seg.kord[,3],C.curr[,min.indexes[2]],col='RED')
legend('topright',c('Original', 'Estimated'),lty=1,col=c('BLACK','RED'))
@




<<imagemebc,fig=TRUE,echo=FALSE>>=


limitsodcurr<-range(C.curr,memb.currents)
par(mfrow=c(2,1))
image.plot(t(memb.currents),main='Membrane currents',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)
image.plot(t(C.curr),main='Estimated MC',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)


@

Smoothing the membrane functions:



<<smoothed,fig=TRUE,echo=FALSE>>=

memb.currents.smoothed<-array(0,c(seg.db, length(time)))
for (t in 1: length(time)){
memb.currents.smoothed[,t]<-ksmooth(seg.kord[,3],memb.currents[,t],"normal", bandwidth=30,x.points=seg.kord[,3])$y
}

limitsodcurr<-range(C.curr,memb.currents.smoothed)
par(mfrow=c(2,1))
image.plot(time,seg.kord[,3],t(memb.currents.smoothed),main='Membrane currents',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)
image.plot(time,seg.kord[,3],t(C.curr),main='Estimated MC',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)


@










%bs_1D_130509_maradekkedd.Rnw
<<splineinterpol,echo=FALSE,fig=FALSE>>=
if(0==1){
#spline interpolaljuk a függvényt, és ugyanazokban a a pontokban számítsuk ki az eltérést...
#egyenlore elteresek van az eredeti és számolt áramok nagyságrendjében, ezért 1-re normáltjukkal számoljunk
#legyenek az interpolációs pontok ugyanazok, mint a source pontok???
ido.nb<-length(time)
#Let's calculate the current densities first
#let's devide each original current by the length of that segment
memb.current.dens<-array(0,c(seg.db, ido.nb))
for (i in 1: seg.db) memb.current.dens[i,]<-memb.currents[i,]/seg.length[i]
#the current densities are only well seen at the soma
#image(memb.current.dens)

#let's devaide the estimated current'a by the distance between them
#mivel feljebb kikommenteltük azt, hogy áramot számítson, így sűrűséget kapunk

#C.dens<-array(0,c(M, ido.nb))
#for (i in 1: M) C.dens[i,]<-C[i,]/delta

limitsodcurr<-range(C.dens,memb.current.dens)

par(mfrow=c(2,1))
image.plot(time,seg.kord[,3],t(memb.current.dens),main='Membrane currents density',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)
image.plot(time,where.cord[,3],t(C.dens),main='Estimated MC density',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)
}
@

After interpolating:

<<splineinterpol2,echo=FALSE,fig=FALSE>>=
####################xinterpolation
if(0==1){
hany.pont<-40
memb.currents.dens.interpol<-array(0,c(hany.pont, ido.nb))
C.dens.interpol<-array(0,c(hany.pont, ido.nb))

interpol.limit<-c(seq(-50,550,length.out=hany.pont))
for(i in 1:length(time)){
memb.currents.dens.interpol[,i]<-interpol(seg.kord[,3],memb.current.dens[,i],interpol.limit)
C.dens.interpol[,i]<-interpol(where.cord[,3],C.dens[,i],interpol.limit)
}
par(mfrow=c(2,1))
limitsodcurr<-range(C.dens,memb.current.dens)
image.plot(time,interpol.limit,t(memb.currents.dens.interpol),main='Membrane currents density',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)
image.plot(time,interpol.limit,t(C.dens.interpol),main='Estimated MC density',xlab="time (ms)",ylab="y (um)",zlim=limitsodcurr)

}
rmse.snap<-array(0,c(1,length(time))) 
measure1<-numeric()
#normalizes rmse
nrmse.snap<-array(0,c(1,length(time)))
error.t<-array(0,c(1,length(time))) #normalied error for evrey time

rmse.snap[i]<-sqrt(mean((memb.currents[,i]-C.curr[,i])^2))
nrmse.snap[i]<-rmse.snap[i]/sqrt(mean((memb.currents[,i]^2)))
#nrmse.snap[i]<-rmse.snap[i]/(max(memb.currents[,i])-min(memb.currents[,i]))
#error.t[i]<-sum((memb.currents.dens.interpol[,i]-C.dens.interpol[,i])^2)#/sum(memb.currents.dens.interpol[,i]^2)


measure1<-sum(abs(C.curr-memb.currents))/sum(abs(C.curr))
rmse.total<-sqrt(mean((memb.currents-C.curr)^2))
nrmse.total<-rmse.total/sqrt(mean((memb.currents^2)))





#parameters
@
%bs_1D_130509_maradekkedd.Rnw
<<writingtofiles,echo=FALSE>>=
#name.output.ksCSD<-paste('out/ksCSD_',base,'_R',R, '_dist',d, '_el',el.nb,'_seg', seg.db, sep='')
#write.table(C,name.output.ksCSD,col.names=FALSE, row.names=FALSE)
#snap RMSE
name.output.tRMSE<-paste('out_branch/tRMSE_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
#write.table(rmse.snap, name.output.tRMSE,col.names=FALSE, row.names=FALSE)
name.output.ntRMSE<-paste('out_branch/normtRMSE_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
#write.table(nrmse.snap, name.output.ntRMSE,col.names=FALSE, row.names=FALSE)
name.output.RMSE.total<-paste('out_branch/RMSEtot_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
#write.table(rmse.total, name.output.RMSE.total,col.names=FALSE, row.names=FALSE)
name.output.nRMSE.total<-paste('out_branch/normRMSEtot_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
write.table(nrmse.total, name.output.nRMSE.total,col.names=FALSE, row.names=FALSE)


name.output.measure1<-paste('out_branch/meaure1_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
write.table(measure1, name.output.measure1,col.names=FALSE, row.names=FALSE)

name.output.measure.curr<-paste('out_branch/measurecurr_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
write.table(measure.curr, name.output.measure.curr,col.names=FALSE, row.names=FALSE)

name.output.measure.peak<-paste('out_branch/measurepeak_',base,'_bwidth',R, '_dist',d, '_el',el.nb,'_seg', seg.db,'_bnum',M, sep='')
write.table(measure.peakness, name.output.measure.peak,col.names=FALSE, row.names=FALSE)

@

<<density,echo=FALSE,fig=TRUE>>=
#curve(inter,-100,500)


#plot(where.cord[,3],C[,min.indexes[2]],col='RED',t='l')


#memb.currents.dens<-array(0,c(where.db,length(time)))
#for(t in 1:length(time)){
#C.d<-memb.currents[,t]/seg.length
#densest<-numeric(length(where.db))
#for(i in 1:where.db){
#for (j in 1: seg.db){
#if((where.cord[i,3]< (seg.kord[j,3]+seg.length[j])) & (where.cord[i,3]> (seg.kord[j,3]-seg.length[j]))) densest[i]<-C.d[j]
#}
#}
#memb.currents.dens[,t]<-densest

#} #t

#lines(seg.kord[,3],memb.currents[,min.indexes[2]]/seg.length,col='RED')



funaramvonal<-function(x) x/seg.length
memb.currents.vonal<-apply(memb.currents,2,funaramvonal) 
memb.currents.vonal.smoothed<-array(0,c(seg.db, length(time)))
for (t in 1: length(time)){
memb.currents.vonal.smoothed[,t]<-ksmooth(seg.kord[,3],memb.currents.vonal[,t], "normal", bandwidth=60,x.points=seg.kord[,3])$y
}



plot(C[,min.indexes],col='RED',t='l')
points(memb.currents[,min.indexes])
points(memb.currents.vonal[,min.indexes])
lines(seg.kord[,3],memb.currents.vonal.smoothed[,min.indexes])
#abline(v=seg.kord[1:seg.db,3])



@

<<cellplot,echo=FALSE,fig=TRUE>>=
library(scatterplot3d)
cellplot<-scatterplot3d(seg.cord[,1],seg.cord[,2],seg.cord[,3],xlim=c(-10,50))
cellplot$points3d(elec.kord[,1],elec.kord[,2],elec.kord[,3])
@


\end{document}

